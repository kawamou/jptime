package jptime

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"net/http"
	"os"
)

type HTTPCSVImporter struct {
	client *http.Client
	url    string
}

func NewHTTPCSVImporter(url string) *HTTPCSVImporter {
	return &HTTPCSVImporter{
		client: http.DefaultClient,
		url:    url,
	}
}

func (h HTTPCSVImporter) Import() (*http.Response, error) {
	resp, err := h.client.Get(h.url)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type LocalCSVImporter struct {
	path string
}

func NewLocalCSVImporter(path string) *LocalCSVImporter {
	return &LocalCSVImporter{
		path: path,
	}
}

func (l LocalCSVImporter) Import() (io.Reader, error) {
	return os.Open(l.path)
}

type GoFileExporter struct {
	dst *os.File
}

func NewGoFileExporter(dst *os.File) *GoFileExporter {
	return &GoFileExporter{
		dst: dst,
	}
}

func (g GoFileExporter) Export(holidays []Holiday) error {
	baseTmpl := `
	// Code generated by foo.go; DO NOT EDIT.
	package jptime

	import "time"

	// Holiday ...
	type Holiday struct {
		Date time.Time // 祝日の日付
		Name string    // 祝日の名称
	}

	var holidays = []Holiday{
	%s
	}
	`
	valueTmpl := `
	{
		Date: time.Date(%v, time.%v, %v, 0, 0, 0, 0, time.Local),
		Name: "%s",
	},
	`
	var tmp string
	for _, h := range holidays {
		tmp = tmp + fmt.Sprintf(valueTmpl, h.Date.Year(), h.Date.Month(), h.Date.Day(), h.Name)
	}
	formatted, err := format.Source([]byte(fmt.Sprintf(baseTmpl, tmp)))
	if err != nil {
		return err
	}
	if _, err := io.Copy(g.dst, bytes.NewReader(formatted)); err != nil {
		return err
	}
	return nil
}
